<!--
  -- Copyright (C) 2008 Google Inc.
  --
  -- Licensed under the Apache License, Version 2.0 (the "License");
  -- you may not use this file except in compliance with the License.
  -- You may obtain a copy of the License at
  --
  -- http://www.apache.org/licenses/LICENSE-2.0
  --
  -- Unless required by applicable law or agreed to in writing, software
  -- distributed under the License is distributed on an "AS IS" BASIS,
  -- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  -- See the License for the specific language governing permissions and
  -- limitations under the License.
  -->

<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">

<html>

<head>
  <title>Cajita Optimization</title>
  <link type="text/css" rel="stylesheet" href="../common/documentStyle.css"/>
  <script type="text/javascript" src="../common/headingNumbers.js"></script>
</head>

<body onload="numberDocument();">

<div class="title">Cajita Optimization</div>

<h1>Problem statement</h1>

<p>We define a Scheme-like capability language, <em>Cajita</em>, which
is roughly that subset of JavaScript without any use of the
<code>this</code> keyword. Expected programming patterns in this
language will create extra allocation overhead.</p>

<h1>Background</h1>

<p>Programming in Cajita, without <code>this</code>, encourages the
use of object literals containing closures to represent object state.
For example, the following is a factory function that creates
representations of a point in Cartesian coordinates:</p>

<pre>
function makePointCajita(x, y) {
  return {
    getX: function () { return x; },
    setX: function (_x) { x = _x; },
    getY: function () { return y; },
    setY: function (_y) { y = _y; }
  };
}
</pre>

<p>The performance problem comes from the fact that the above code
creates 5 allocations for each invocation: one object literal and 4
closures for the functions assigned to <code>getX</code>,
<code>setX</code>, <code>getY</code> and <code>setY</code>
respectively. In general, for an object with <em>N</em> methods, we
incur <em>O(N)</em> allocations.<p>

<h1>Proposal</h1>

<p>To solve this problem, we will first rewrite to a semantically
equivalent representation, which has the same allocation overhead. Our
rewriting reifies <em>into</em> the language the scope chains that are
automatically created and referred to by closures, and rewrite the
code so as to suppress the automatic creation of scopes.</p>

<p>Having thus given ourselves a place to stand from which we can make
some observations about control flow, we can perform the necessary
optimizations.</p>

<h2>A simple strategy</h2>

<p>Our first attack is based on the observation that, if a developer
were to write <code>makePointCajita</code> to use <code>this</code>,
the resulting allocations would be <em>O(1)</em>. Of course, the code
is no longer in Cajita:</p>

<pre>
function makePointNonCajita(x, y) {
  return {
    x: x, y: y,
    getX: function () { return this.x; },
    setX: function (_x) { this.x = _x; },
    getY: function () { return this.y; },
    setY: function (_y) { this.y = _y; }
  };
}
</pre>

<p>However, we can build an automated rewriting strategy based on the
same intuition, which works for <em>some</em> cases. Our trick is to
use <code>this</code> as a reference to the reified scope chain within
which a closure was instantiated, and take advantage of the automatic
<code>this</code> binding to supply that reference to the function
whenever it is called. We recognize as special the expression:</p>

<pre>
{
  <em>name<sub>1</sub></em>: <em>function<sub>1</sub></em>,
  <em>name<sub>2</sub></em>: <em>function<sub>2</sub></em>,
  <em>...</em>,
  <em>name<sub>n</sub></em>: <em>function<sub>n</sub></em>,
}
</pre>

<p>and rewrite it as per the following example, where we create
1-dimensional points for simplicity:</p>

<table border="0"><tr>

<td valign="top"><pre>
function make1DPointCajita(x) {
  var b = Math.random();
  return {
    getX: function () { return x + b; },
    setX: function (_x) { x = _x - b; }
  };
}

var p = make1DPointCajita(3);
p.getX();
</pre></td>

<td valign="top"><font size="+5">&rarr;</font></td>

<td valign="top"><pre>
<font color="green">// Rewritten "getX" function, hoisted and this-ed</font>
function fn_getX___() { return this.x + this.b; }

<font color="green">// Rewritten "setX" function, hoisted and this-ed</font>
function fn_setX___(_x) { this.x = _x - this.b; }

<font color="green">// Original function, not hoisted</font>
function make1DPointCajita(x) {

  <font color="green">// Create reification of local scope</font>
  var s0___ = ___.newScope();

  <font color="green">// Explicitly push args onto local scope</font>
  s0___.x = x;

  <font color="green">// Push local "b" onto local scope</font>
  s0___.b = Math.random();

  <font color="green">// Create return result</font>
  var tmp0___ = s0___.beget();

  <font color="green">// Assign functions to return result</font>
  o.getX = fn_getX___;
  o.setX = fn_setX___;

  return o;
}

var p = make1DPointCajita(3);

<font color="green">// Calling supplies "p" as "this"</font>
p.getX();
</pre></td>

</tr></table>

<p>Note that we are using JavaScript <a
href="http://javascript.crockford.com/prototypal.html">prototypal
inheritance</a> to allow the reified scopes and objects to inherit
from one another in a simulation of the language's native lexical
scoping. This works for any level of nesting of functions.</p>

<p>There is one detail: when a Cajita developer gets the value of a
property of an object, they expect a closure rather than a function
requiring <code>this</code>. <em>Our optimization relies on this
pattern of access being relatively rare.</em> Since all property reads
in Cajita go through <code>readPub</code>, we can add logic there to
bind the function when necessary. We already do the following
rewriting (approximately -- many details omitted):</p>

<table border="0"><tr>

<td valign="top"><pre>
var f = o.getX;
f();
</pre></td>

<td valign="top"><font size="+5">&rarr;</font></td>

<td valign="top"><pre>
var f = ___.readPub(o, 'foo');
f();
</pre></td>
</tr></table>

<p>and the corresponding <code>readPub</code> implementation is
something like:</p>

<pre>
function readPub(o, name) {
  if (typeof o[name] === 'function') {
    if (!o[name + '_boundFunction___']) {   
      <font color="green">// Memoize result</font>
      o[name + '_boundFunction___'] = o[name].bind(o);
    }
    return o[name + '_boundFunction___'];
  } else {
    <font color="green">// Other cases here </font>
  }
}
</pre>

<p>And with this, our optimization is invisible to the Cajita
programmer.

<h2>Problems with the simple approach</h2>

<p>The main practical problem with this approach is that Cajita
inheritance using a "mixin" style cannot take advantage of it.
Consider the following mixin that adds <code>hello</code> and
<code>goodbye</code> methods to a point:</p>

<pre>
function mixSmartPoint(aPoint, name) {
  aPoint.hello = function() { return 'Hello from ' + name); };
  aPoint.goodbye = function() { return 'Goodbye from ' + name; };
}
</pre>

<p>Clearly, this does not fit the object literal matching pattern. Yet
there is a more fundamental issue that prevents us from combining the
scope chains of <code>hello</code> and <code>goodbye</code>; for this,
we need a different example that forces the general case:</p>

<pre>
function mixWeirdPoint(aPoint, name, isHello) {
  if (isHello) {
    aPoint.hello = function() { return 'Hello from ' + name); };
  } else {
    aPoint.goodbye = function() { return 'Goodbye from ' + name; };
  }
}

var p = make1DPointCajita(3);
mixWeirdPoint(p, 'pat', true);
mixWeirdPoint(p, 'tom', false);

assertEquals('Hello from pat', p.hello());
assertEquals('Goodbye from tom', p.goodbye());
</pre>

<p>Note that <code>mixWeirdPoint</code> is called multiple times on
the same object. We want each of the functions <code>hello</code> and
<code>goodbye</code> to get the correct instantiation of the lexical
scope of <code>mixWeirdPoint</code>. Yet there is no "second place" on
the input parameter <code>aPoint</code> in which to store the extra
scopes; its prototypal inheritance reference already points to the
scope of the <code>make1DPointCajita</code> function where it was
created. Any simple attempt to wire up a solution ends up wrapping
each of <code>hello</code> and <code>goodbye</code> in a closure,
which defeats our purpose.</p>

<h2>A better alternative</h2>

<p>We now have enough background to define our actual, proposed
rewriting, which <em>for the moment</em> brings us back to
<em>O(N)</em> allocations for <em>N</em> methods on an object but, as
we hinted earlier, gives us a place to stand for optimizations. And,
we claim, this new strategy <em>does</em> work for the general
pathological case of <code>mixWeirdPoint</code>.</p>

<p>The key is to store on each hoisted function a GUID (guaranteed
unique in any execution context) that identifies the scope on the
owning object for that specific function. Thus each function may now
have its own reified scope, stored not in a closure but in the owning
object. Each function now has an extra first parameter,
<code>s___</code>, allowing its caller to pass in its scope:</p>

<table border="0"><tr>

<td valign="top"><pre>
function make1DPointCajita(x) {
  var b = Math.random();
  return {
    getX: function () { return x + b; },
    setX: function (_x) { x = _x - b; }
  };
}
</pre></td>

<td valign="top"><font size="+5">&rarr;</font></td>

<td valign="top"><pre>
<font color="green">// Rewritten "getX" function, hoisted</font>
function fn_getX___(s___) { return s___.x + s___.b; }
fn_getX___.guid___ = ___.newGuid();

<font color="green">// Rewritten "setX" function, hoisted</font>
function fn_setX___(s___, _x) { s___.x = _x - s___.b; }
fn_setX___.guid___ = ___.newGuid();

<font color="green">// Original function, not hoisted</font>
function make1DPointCajita(x) {

  <font color="green">// Create reification of local scope</font>
  var s0___ = ___.newScope();

  <font color="green">// Explicitly push args onto local scope</font>
  s0___.x = x;

  <font color="green">// Push local "b" onto local scope</font>
  s0___.b = Math.random();

  <font color="green">// Beget scope for "getX" and assign</font>
  var s1___ = s0___.beget();
  o.getX = fn_getX___;
  o[fn_getX___.guid___] = s1___;

  <font color="green">// Beget scope for "setX" and assign</font>
  var s2___ = s0___.beget();
  o.setX = fn_setX___;
  o[fn_setX___.guid___] = s2___;

  return o;
}
</pre></td>

</tr></table>

<p>Now, even in the simple case of calling <code>o.getX()</code>, we
need some extra magic. Luckily, all such calls get translated:</p>

<table border="0"><tr>

<td valign="top"><pre>
o.getX();
</pre></td>

<td valign="top"><font size="+5">&rarr;</font></td>

<td valign="top"><pre>
___.callPub(o, 'getX');
</pre></td>

</tr></table>

<p>and our implementation of <code>callPub</code> is:</p>

<pre>
function callPub(o, name, args) {
  var f = o[name];
  if (f.guid___) {
    f.apply(USELESS, [o[f.guid___]].concat(args));
  } else {
    <font color="green">// Other cases</font>
  }
}
</pre>

<p>As before, we need a <code>readPub</code> that binds the function
value to its owning object should the value escape:</p>

<pre>
function readPub(o, name) {
  if (typeof o[name] === 'function') {
    if (!o[name + '_boundFunction___']) {
      <font color="green">// Memoize result</font>
      o[name + '_boundFunction___'] = o[name].bind(<span style="background-color: yellow">o[o[name].guid___]</span>);
    }
    return o[name + '_boundFunction___'];
  } else {
    <font color="green">// Other cases here </font>
  }
}
</pre>

<p>Finally, note carefully why we have to <code>beget</code> a new
scope object for each function assigned to the target object.
Functions like <code>mixWeirdPoint</code> will assign different scopes
to different functions, and we want these to be indexable by the GUID
of the function. By assigning a new scope object to each function, we
can be sure that, regardless of the control flow, each function will
be given the correct scope object.</p>

<h2>Optimizations</h2>

<p>With the scheme we just described in hand, we can observe cases in
which we are being more conservative than necessary and reduce our
allocation overhead. Our key technique is to do a simple control flow
analysis on a function such as <code>make1DPointCajita</code>. If some
set of functions always gets assigned to an object <em>together</em>,
then they can share the same scope object. Hence the functions
<code>getX</code> and <code>setX</code> in
<code>make1DPointCajita</code> can share the same scope object:</p>

<table border="0"><tr>

<td valign="top"><pre>
function make1DPointCajita(x) {
  var b = Math.random();
  return {
    getX: function () { return x + b; },
    setX: function (_x) { x = _x - b; }
  };
}
</pre></td>

<td valign="top"><font size="+5">&rarr;</font></td>

<td valign="top"><pre>
<font color="green">// Rewritten "getX" function, hoisted</font>
function fn_getX___(s___) { return s___.x + s___.b; }
fn_getX___.guid___ = ___.newGuid();

<font color="green">// Rewritten "setX" function, hoisted</font>
function fn_setX___(s___, _x) { s___.x = _x - s___.b; }
fn_setX___.guid___ = fn_getX___.guid___; <font color="green">// Same GUID!</font>

<font color="green">// Original function, not hoisted</font>
function make1DPointCajita(x) {

  <font color="green">// Create reification of local scope</font>
  var s0___ = ___.newScope();

  <font color="green">// Explicitly push args onto local scope</font>
  s0___.x = x;

  <font color="green">// Push local "b" onto local scope</font>
  s0___.b = Math.random();

  <font color="green">// Beget scope for "getX" and "setX" and assign</font>
  var s1___ = s0___.beget();
  o.getX = fn_getX___;
  o[fn_getX___.guid___] = s1___;
  o.setX = fn_setX___;

  return o;
}
</pre></td>

</tr></table>

<p>The key optimization is that we managed to get away with one
<code>beget</code> rather than two.</p>

<h2>Garbage collection</h2>

<p>As a final problem, if the function properties on an object are
overwritten or <code>delete</code>d, we should also clear the
reference to its scope. Since these are shared, we need to maintain a
reference count on an object to remember how many of its remaining
functions still require a particular scope, and clear the scope
reference when the count goes to zero. We can add logic to
<code>setPub</code> and <code>deletePub</code> to implement these
cases.</p>

</body>

</html>
