<!--
  --
  -- Licensed under the Apache License, Version 2.0 (the "License");
  -- you may not use this file except in compliance with the License.
  -- You may obtain a copy of the License at
  --
  -- http://www.apache.org/licenses/LICENSE-2.0
  --
  -- Unless required by applicable law or agreed to in writing, software
  -- distributed under the License is distributed on an "AS IS" BASIS,
  -- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  -- See the License for the specific language governing permissions and
  -- limitations under the License.
  -->

<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">

<html>

<head>
  <title>Module System for ES-Harmony</title>
  <link type="text/css" rel="stylesheet" href="../../../../doc/html/common/documentStyle.css"/>
  <link type="text/css" rel="stylesheet" href="../../../../doc/html/common/prettify.css"/>
  <script type="text/javascript" src="../../../../doc/html/common/prettify.js"></script>
  <script type="text/javascript"  src="../../../../doc/html/common/headingNumbers.js"></script>

  <script type="text/javascript">
    function doOnload() {
      numberDocument();
      prettyPrint();
    }
  </script>

</head>

<body onload="doOnload();">

<div class="title">Module System for ES-Harmony</div>

<h1>Summary</h1>

<p>This is a proposal for a module system for inclusion in ES-Harmony
and possible prototyping prior to standardization.</p>

<h1>Informal description</h1>

<h2>Example module</h2>

<p>Our example of a module is a resource stored at the URL:</p>

<blockquote><code class="prettyprint">http://example.com/someModule.js</code></blockquote>

<p>containing the text:</p>

<pre class="prettyprint">
var isOn = false;
{
  toggle: function() {
    document.setBackgroundColor(isOn ?
        bgColor : '#ffffff');
    isOn = !isOn;
  },
  set: function() {
    document.setBackgroundColor(bgColor);
    isOn = true;
};
</pre>

<p>Note that this is merely a snippet of top-level ES code without any
new keywords. The code has two free variables, <code
class="prettyprint">document</code> and <code
class="prettyprint">bgColor</code>. It declares the state variable
<code class="prettyprint">isOn</code>. Its last statement is an
expression returning an object literal containing closures that
capture both the state variable <code class="prettyprint">isOn</code>
and the free variables.</p>

<h2>Loading the module</h2>

<p>Loading a module is done through a <em>loader</em>. When invoked
as, for example:</p>

<pre class="prettyprint">
var m = loader.loadUrl('http://example.com/someModule.js');
</pre>

<p>the result, <code class="prettyprint">m</code>, is a <code
class="prettyprint">Function</code> object that is semantically
equivalent to the results of a strict <code
class="prettyprint">eval()</code> of the following code (assuming
<code class="prettyprint">$</code> is an unmentionable, automatically
generated identifier):</p>

<pre class="prettyprint">
<span style="background-color: #ffffe0">function($) {</span>
  <span style="background-color: #ffffe0">var background = $.background;</span>
  <span style="background-color: #ffffe0">var document = $.document;</span>
  var isOn = false;
  <span style="background-color: #ffffe0">return</span> {
    toggle: function() {
      document.setBackgroundColor(isOn ?
          background : '#ffffff');
      isOn = !isOn;
    },
    set: function() {
      document.setBackgroundColor(background);
      isOn = true;
  };
<span style="background-color: #ffffe0">};</span>
</pre>

<p>This function has no free variables: free variables of the original
code are rewritten to be snapshots of the contents of a supplied
object literal. In the inner function, <code
class="prettyprint">this</code> is always <code
class="prettyprint">undefined</code>. And the function <code
class="prettyprint">return</code>s the value of the last expression in
the original code. It is the responsibility of the loader to perform
the necessary analysis on the loaded code to do this
transformation.</p>

<div class="note">Is <code class="prettyprint">this.Array ===
Array</code>, as one would expect from legacy top-level ES code? Not
according to this trick. What then?</div>

<h2>Instantiating the module</h2>

<p>To <em>instantiate</em> the module is to call its module function,
thus creating an independent instance of its internal state variables.
Given a loaded module <code class="prettyprint">m</code> as
previously, we can, within the same client code, create two instances
as follows:</p>

<pre class="prettyprint">
var docA = /* ... */;
var colorA = /* ... */;

var docB = /* ... */;
var colorB = /* ... */;

// Instantiate and assign entire return value of module function
var controlA = m({ document: docA, bgColor: colorA });

// Use the first module instance ...
controlA.toggle();
controlA.set();

// Instantiate with destructuring assignment to individual symbols
var { toggle: toggleB, set: setB } = m({ document: docB, bgColor: colorB });

// Use the second module instance ...
toggleB();
setB();
</pre>

<p>When we only need to create one instance, we can combine loading
and instantiation, with destructuring assignment, into one
expression:</p>

<pre class="prettyprint">
var docA = /* ... */;
var colorA = /* ... */;

var { toggle: toggleIt, set: setIt } =
    loader.loadUrl('http://example.com/someModule.js')
    ({ document: docA, bgColor: colorA });

toggleIt();
setIt();
</pre>

<p>An important point is that, since the module function has no free
variables, a loader may cache it without loss of isolation between
instances.</p>

<div class="note">The fact of caching without loss of isolation is
only important if this is being done in user-level code. Otherwise,
the runtime can control the scope chain. As it likely has to in order
to make the top-level <code class="prettyprint">this</code> work as
expected (see above). Unless we punt on that behavior. More thought
required.</div>

<h2>Asynchronous loading</h2>

<p>In some cases, a loader may need to (say) use an HTTP request to
fetch a module's text. In this case, the loader's methods execute
asynchronously. These methods return a <em>future</em> object. Define
a future such that the behavior of the following:</p>

<pre class="prettyprint">
var aFuture = /* a future */;
var aFunction = function(a) { /* some code */ };
aFuture.when(<em>arg<sub>0</sub>, arg<sub>1</sub>, ..., arg<sub>k</sub></em>, aFunction);
</pre>

<p>is to invoke the following when the future is resolved:</p>

<pre class="prettyprint">
aFunction(aFuture.call(undefined, <em>arg<sub>0</sub>, arg<sub>1</sub>, ..., arg<sub>k</sub></em>));
</pre>

<p>If <code class="prettyprint">loadUrl</code> returns a future, the
syntax for module loading would therefore be:</p>

<pre class="prettyprint">
var document = /* ... */;
var background = /* ... */;

loader.loadUrl('http://example.com/someModule.js').when(
  { document: myDoc, background: aColor },
  function({ toggle: toggleIt, set: setIt }) {

  toggleIt();
  setIt();

  // Remainder of code depending on the module
  // ...
});
</pre>

<h2>Variant loaders</h2>

<p>Nothing in this proposal assumes that HTTP resources are the only
way to designate ES modules. For example, a loader could retrieve
modules from a database based on a dotted name and version string, and
be used in the same manner:</p>

<pre class="prettyprint">
dbLoader.lmod('com.example.docbgcolors', '1.7+', true).when(
  { document: myDoc, background: aColor },
  function({ toggle: toggleIt, set: setIt }) {

  // ...
});
</pre>

<h2>Module metadata</h2>

<p>To enforce clean isolation, our proposal does not allow modules to
name themselves or their contents in their client's universe of
discourse. The loader is responsible for maintaining the namespace of
modules, while the instantiating code is responsible for maintaining
the names to which (portions of) module instances are assigned.</p>

<p>For some purposes, it may be useful for a module to assign metadata
to itself, to be used at the option of its clients. Our proposal does
not cover this in any detail, but we imagine it could be used as
follows:</p>

<pre class="prettyprint">
var m = loader.loadUrl('http://example.com/someModule.js');

m.name;    // &rarr; 'com.example.someModule'
m.version; // &rarr; '1.8.10b'
m.author;  // &rarr; 'Alyssa P Hacker &lt;hacker@example.com&gt;'
m.imports; // &rarr; [ 'document', 'background' ]
m.exports; // &rarr; [ 'toggleIt', 'setIt' ]
</pre>

<h1>Standardization issues</h1>

<p>Strictly speaking, the functionality in this proposal can be
written entirely in pure ES (possibly with the help of something like
the <code class="prettyprint">XMLHttpRequest</code> object provided by
Web browsers). That said, we believe the following items are
candidates for standardization.</p>

<h2>Module naming</h2>

<h3>What</h3>

<p>A standard scheme for naming modules; most likely, this would just
be a statement that modules are identified by unique URIs.</p>

<h3>Pro</h3>

<p>The loader interface could then be standardized. In the typical
case, where modules are HTTP resources, the module's URI serves as its
global name; the usual combination of DNS and webadmins ensures that
the responsible parties deal with the namespace issues. ES embeddings
can set up local mirrors for module resources yet continue to identify
them by their original URI. For modules stored in other than HTTP
resources, variant URI schemes can be enlisted. In fact, the <code
class="prettyprint">urn:</code> scheme can be used for location
independent naming.</p>

<h3>Con</h3>

<p>At the risk of introducing a strawman, consider a typical usage of
this sort of scheme: naming JDBC databases in Java enterprise
applications. The JDBC URIs, typically of the form:</p>

<pre class="prettyprint">
jdbc:dbnet://wombat:356/fred
jdbc:odbc:wombat;CacheSize=20;ExtensionCase=LOWER
</pre>

<p>invoke JDBC "drivers" which must be registered elsewhere in the
system. The principal use for this is a form of dependency injection:
the code loading the database typically reads the JDBC URI from a
configuration file, allowing an administrator to install and remove
database drivers, and covariantly modify the configuration URI, as
needed. However, given that our modules are first-class objects, and
that ES is a dynamic language, this dependency injection can easily be
built by passing the module objects directly. So, for example, in ES,
a system could store a <em>direct</em> reference to a database driver
module in some configuration, and an application could do:</p>

<pre class="prettyprint">
var config = /* get the configuration params */;

var dbmodule = config.get('com.wombat.dbdriver');
var database = dbmodule();
database.getRows( /* ... */ );
</pre>

<h3>Recommendation</h3>

<p>Do not standardize module naming for ES. Recognize that Web browser
environments will likely provide a default (and possibly standardized,
but not by ES) loader, implemented as a host object that uses HTTP
URLs to identify modules.</p>

<h2>Loader support</h2>

<h3>What</h3>

<p>Imagine that we implement module loading in terms of a strict <code
class="prettyprint">eval</code> operator. To avoid capturing variables
from the invoking code, the loader must perform a parse and scope
analysis of the module code. ES should provide a standard interface
for this using native support. For example, the "&mu;kernel" of a
loader, taking program text and producing a module function, could be
a standard.</p>

<div class="note">If the scope chain of the module must be fixed up,
we <em>need</em> native support.</div>

<h3>Pro</h3>

<p>Doing this analysis in plain ES requires implementing a parser and
scope analysis in ES. This is exhorbitantly expensive.</p>

<h3>Con</h3>

<p>Native loaders, available as host objects (e.g., in Web browsers
and standardized as such) can do this without the need for any further
ES standards.</p>

<h3>Recommendation</h3>

<div class="note">TBD pending scope chain issues.</div>

<h2>Standardized module format</h2>

<h3>What</h3>

<p>A minimal specification for how a module is to receive imports
from, and export symbols to, its instantiating code.</p>

<p>In this proposal, free variables of the module code are imports,
while the value of the last expression is an export. This is backwards
compatible with existing ES top-level code. See <em>Alternatives and
rationale</em> below for further discussion.</p>

<h3>Pro</h3>

<p>The mechanics of how a module is stored, addressed or loaded are
easily pluggable, but making a module's program text fit a standard
format is a requirement on the original module developer and is
therefore an important up-front decision that cannot easily be
revised. If ES does not standardize a way to do this, there will be a
multitude of incompatible approaches.</p>

<p>While the <em>concrete symbols</em> imported and exported by
modules may differ, making the import/export scheme a standard allows
delegation and chaining of module loading and instantiation tasks
independently of the details of the modules being loaded.</p>

<h3>Con</h3>

<p>Given that this proposal can be implemented in plain ES, no further
mechanism is needed.</p>

<h3>Recommendation</h3>

<p>ES should standardize this mechanism for the reasons given under
<em>Pro</em>.</p>

<h2>Module metadata</h2>

<h3>What</h3>

<p>Provide a standard way for a parsed module function to provide
meta-information about itself. This information would be exposed as
transitively immutable data available from the properties of the
module function itself.</p>

<h3>Pro</h3>

<p>This would allow development tools and system administrators to
better track the progeny of modules. In the absence of such a scheme,
multiple nonstandard ones will be invented. </p>

<h3>Con</h3>

<p>Given that this proposal can be implemented in plain ES, no further
mechanism is needed. There is a risk that this would be misunderstood
as a scheme for storing "static" or "global" variables on the module;
if this becomes common, systems using ES would become harder to
maintain.</p>

<h3>Recommendation</h3>

<p>We tend towards supporting this proposal for the reasons given
under <em>Pro</em>.</p>

<h1>Alternatives and rationale</h1>

<h2>Explicit module syntax</h2>

<p>We considered an approach where a developer could embed, in their
code, a <code class="prettyprint">module</code> block that would
introduce a new lexical scope root:</p>

<pre class="prettyprint">
var a, b, c;

module (b) {
  // New lexical scope root
  // Code here can only see variable 'b'
};
</pre>

<p>This could be a candidate for an explicit declaration of top-level
modules as well, so the top level of a module file could be:</p>

<pre class="prettyprint">
module (x, y, z) {

  // Module code that imports 'x', 'y' and 'z'
  // ...
};
</pre>

<p>We rejected this idea via a case analysis of the circumstances
under which it may be used:</p>

<ol>

  <li><p>As a construct within the same compilation unit, it is
  redundant with other techniques (such as closures) for managing the
  lexical scope. It also requires extra syntax beyond what we show
  here for passing in symbols and receiving exports.</p></li>

  <li><p>If it were adopted as part of the required structure of a
  top-level ES module compilation unit, it would not be compatible
  with existing ES programs.</p></li>
  
</ol>

<h2>Import and export mechanisms</h2>

<p>In our proposal, the module is desugared to code that obeys strict
lexical scoping yet obtains its imports from a dynamic map. A module's
exports are simply the value of its last expression evaluated before
it "falls off the end" of its execution.</p>

<p>This has the benefit of introducing no new syntax. It has the
disadvantage that, although existing ES code could
<em>theoretically</em> be (re)used as modules, there would be no
practical way to extract the exported symbols from that code, since it
would not be written to return all the exports in its last
expression.</p>

<p>In this section, we will examine some alternatives. The important
points we wish to preserve under all circumstances are:</p>

<ul>

<li><p>Isolation between a module's scope and that of its
instantiating code. The instantiating code cannot force new bindings
into a module, and the module cannot force new bindings into its
instantiating code.</p></li>

<li><p>Multiple instantiation of modules. Each module should be parsed
once to a first-class value that is (or, <em>can be</em>) returned to
the client as such. This value presents an API such that the client
can create independent copies of the contents of the module, each of
which is isolated from all others.</p></li>

</ul>

<h3>Rendezvous at module's top-level dynamic scope</h3>

<p>Imagine that the module code can be evaluated in a new top-level
scope as a standard ES <em>Program</em>. This scope is pre-populated
with the imports, as provided by the instantiating code. New top-level
declarations in the module are placed in the top-level scope. When the
module code has run to completion, the instantiating code may harvest
symbols from that scope.</p>

<div class="figure"><img src="moduleScope3Level.png"/></div>

<p>This has the advantage that the expected global <code
class="prettyprint">this</code> binding works as usual; specifically,
modules can <code class="prettyprint">delete</code> and declare
variables at the top level and see the normal behavior.</p>

<p>One disadvantage is that, if a module wishes to isolate portions of
itself, it must do so using closures:</p>

<pre class="prettyprint">
var x; // Variable 'x' is exported (or shadows an import)

(function() {
  var y; // Variable 'y' is module private
  x = /* ... */; // Assign to and initialize exported variables
})();
</pre>

<p>Another disadvantage is that, <em>as described so far</em>, it does
not separate module loading and instantiation. Specifically, there is
not a first-class value returned to the client code from module
loading that can be used multiple times for instantiation. This means
that the client has to rely on the loader's caching of the module's
AST for efficiency but, worse, we make it impossible for the client to
ensure they get the same module every time since the module may have
changed and the loader may or may not choose to (say) reload from the
HTTP resource every time.</p>

<p>There seems to be a way to rescue this proposal: we could simply
always evaluate the module without <em>any</em> imports (beyond
primordial objects). The only exports such a module can provide are
now just constants and functions which, when supplied with information
by the client, can produce outputs. However, since these functions,
when run, do not cause a new scope chain to be constructed, they can
share state; hence the module is essentially a singleton and any
objects instantiated from the module must be assumed to depend on one
another. This interdependency is detrimental to reasoning about both
security and code modularity.</p>

<p>Of course, we may simply state that, as part of its contract, a
loader (or, the standardized loader &mu;kernel) compiles the text of a
module and returns a special host object that has some API such that,
when called, it evaluates the contents of the module in an isolated
scope. Indeed, this may be the only way to achieve the maximum legacy
compatibility <em>and</em> the proper isolation.</p>

<h3>Explicit calls to import and export facility</h3>

<p>We may require modules to include explicit calls to <code
class="prettyprint">import</code> or <code
class="prettyprint">export</code> functions. We eschewed this option
because it gets in the way of using (re)existing pieces of ES
top-level code as modules.</p>

<h3>Allowing <code class="prettyprint">return</code> at the top level</h3>

<p>We could allow a module to export symbols by <code
class="prettyprint">return</code>ing a value (presumably an object
literal). This requires allowing class="prettyprint">return</code> in
a <em>Program</em> production. If adopted in conjunction with the idea
that, for backwards compatibility, and in the absence of a <code
class="prettyprint">return</code>, the last expression is evaluated,
this might be a good feature.</p>

</body>

</html>
