#!/usr/bin/env rune

# Copyright (C) 2007 Google Inc.
#      
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ..............................................................................


pragma.syntax("0.9")

def js__quasiParser := <import:com.google.caja.js__quasiParser>


/**
 * We assume that a JavaScript AST implements the following JsAst
 * interface. 
 */
interface JsAst {

    /** 
     * Call one of the visitor's visit* methods according to the kind
     * of JsAst node this is.
     * <p>
     * Return whatever that visitor returns. The visitors used by
     * expand.emaker visit only ScopeJsAst nodes and return translated
     * JsAst nodes.
     */
    to welcome(visitor) :any

    /** Is this an identifier */
    to isIdent() :boolean

    /** Is this a variable declaration or reference? */
    to isVarName() :boolean

    /**
     * An expression isSimple if it's a variable or a literal scalar,
     * or possibly even a short literal string.
     * <p>
     * Used to determine whether the expression can be safely repeated
     * (barring possibly conflicting writes). If it's not simple, then
     * a temporary needs to be introduced to prevent, e.g., excess
     * side effects.
     */
    to isSimple() :boolean

    /**
     * Does this node mention "this" freely?
     * <p>
     * If "this" is only mentioned within a function definition within
     * this node, then the result is <tt>false</tt>, since that "this"
     * isn't a free occurrence.
     */
    to hasFreeThis() :boolean

    /**
     * Does this node mention "arguments" freely?
     * <p>
     * If "arguments" is only mentioned within a function definition
     * within this node, then the result is <tt>false</tt>, since that
     * "arguments" isn't a free occurrence.
     */
    to hasFreeArguments() :boolean    
}

def anyFreeThis(astList) :boolean {
    for ast in astList {
        if (ast.hasFreeThis()) { return true }
    }
    return false
}

def anyFreeArguments(astList) :boolean {
    for ast in astList {
        if (ast.hasFreeArguments()) { return true }
    }
    return false
}

/**
 * The ASTs being visited must already be annotated with the results
 * of a valid full scope analysis, such that they implement the
 * following ScopedJsAst interface.
 */
interface ScopedJsAst extends JsAst {

    /** Is this a global variable declaration or reference? */
    to isGlobal() :boolean

    /** Is this the name of a named function? */
    to isFuncName() :boolean

    /** 
     * Is this the name of a named constructor function? 
     * <p>
     * x.isCtorName() implies x.isFuncName()
     */
    to isCtorName() :boolean

    /**
     * Is this node an expression being evaluated for its value?
     */
    to isForValue() :boolean
}


def makeModuleScope(outerAst :ScopedJsAst) {
    if (outerAst.hasFreeArguments()) {
        throw(`Can't use 'arguments' outside function`)
    }

    var tempNum := 0

    def makeScope(ast :ScopedJsAst) {
        var temps := []
    
        def scope {
    
            /**
             * Make a new scope object representing the lexical scope
             * introduced by function func, which must be directly nested
             * within the lexical scope represented by this scope object.
             */
            to nest(func :ScopedJsAst) { return makeScope(func) }
    
            /**
             * 
             */
            to makeTemp() :JsAst {
                def result := js(`t${tempNum}___`)
                temps with= result
                tempNum += 1
                return result
            }

            /**
             * In addition to possibly declaring the temporaries accumulated
             * by makeTemp(), if this scope is for a function whose body
             * freely mentions "arguments", then this should also include the
             * declaration js`var ___args___ = ___.args(arguments)`
             */
            to tempDefs() :List[JsAst] {
                var result := []
                if (ast.hasFreeArguments()) {
                    results with= js`var ___args___ = ___.args(arguments)`
                }
                for temp in temps {
                    results with= js`var $temp;`
                }
                return result;
            }
        }
        return scope
    }
    return makeScope(outerAst)
}



def expand

/** 
 * Given a list of untranslated expressions, return a list 
 * of translated expressions.
 */
def expandAll(exprs, scope) {
    var result := []
    for e in exprs {
        result with= expand(e, scope)
    }
    return result
}

/** 
 * Given an untranslated expression whose translated value
 * must appear multiple places, return a pair of a translated
 * expression for the first appearance and a translated 
 * expression for the remaining appearances.
 * <p>
 * XXX TODO: Refactor the introduction of temps so we can switch
 * whether to 
 * <ul>
 * <li>simple accumulate them as here,
 * <li>accumulate them, but release them soon after they're no longer
 *     needed, or
 * <li>use the <tt>(function(){...})()</tt> trick to create a 
 *     let-like nested scope which will automatically do the right
 *     thing. 
 * </ul>
 */
def reuse(e, scope) {
    def e2 := expand(e, scope)
    if (e2.isSimple()) {
        return [e2,e2]
    } else {
        def temp := scope.makeTemp()
        return [js`$temp = $e2`, temp]
    }
}

/**
 * Given a list of untranslated expressions whose translated
 * values must appear multiple places, return a pair of
 * a list of all the translated first appearances and all the
 * translated remaining appearances.
 */
def reuseAll(exprs, scope) {
    var e2s := []
    var e3s := []
    for e in exprs {
        def [e2,e3] := reuse(e, scope)
        e2s with= e2
        e3s with= e3
    }
    return [e2s,e3s]
}

/**
 * Given that member is an untranslated expression that may 
 * be a method in the context of function name fname, return 
 * the corresponding translated expression.
 */
def expandMember(fname, member, scope) {
    if (!fname.isFuncName())              { throw(`internal: not statically a function name: $fname`) }
    
    return switch (member) {
        match js`function(@ps*) {@bs*}` ? 
              anyFreeThis(bs)             { def scope2 := scope.nest(member)
                                            def b2s    := expandAll(bs, scope2)
                                            js`___.method($fname,function($ps*) {
                                                 ${scope2.tempDefs()}*;
                                                 $b2s*
                                               })`
                                          }
        match _                           { expand(member, scope) }            
}

/**
 * Given that memberMap is a JSON object-map expression whose values
 * may be methods in the context of function name fname, return the
 * corresponding translated object-map expression. 
 */
def expandMemberMap(fname, memberMap, scope) {
    if (!fname.isFuncName())              { throw(`internal: not statically a function name: $fname`) }
    
    return switch (memberMap) {
        match js`({})`                    { js`({})` }
        match js`({@{key}_: @_, @_*})`    { throw(`Key may not end in "_": ${key}_`) }
        match js`({@key: @mem, @rests*})` ?
              key.isIdent()               { def mem2 := expandMember(fname, mem, scope)
                                            def rest2s := expandMemberMap(fname, rests, scope)
                                            js`({$key: $mem2, $rest2s*})`
                                          }
        match js`({@keyExpr: @_, @_*})`   { throw(`Key expressions not yet supported: $keyExpr`) }
        match _                           { throw(`Map expression expected: $memberMap`) }
    }
}

/**
 * Given that v is an untranslated defining occurrence of a variable
 * name and rValue is the <b>already-translated</b> expression for the
 * value to initialize it with, return the translated definition.
 */
def expandDef(v, rValue) {
    if (v.isGlobal()) {
        return js`___OUTERS___.$v = $rValue`
    } else {
        return js`var $v = $rValue`
    }
}
                                                
/**
 * Given an untranslated expression and a scope, return a
 * corresponding translated expression.
 */
bind expand(e, scope) {
    return e.welcome(def visitor {
        to visitWith()                          { throw(`"with" disallowed: $e`) }
        to visitVar() { return switch (e) {
            match js`arguments`                 { js`___args___` }
            match js`@{_}__`                    { throw(`Variables cannot end in "__": $e`) }
            match js`@{_}_` ? e.isGlobal()      { throw(`Globals cannot end in "_": $e`) }

            # Constructor names can only be used in those static cases
            # enumerated by other productions which exempt it from
            # further expansion.
            match _ ? e.isCtorName()            { throw(`Constructors are not first class: $e`) }

            # Any first non-initialization use of a non-constructor
            # function name freezes it, dynamically preventing further
            # initialization. 
            match _ ? e.isFuncName()            { js`___.primFreeze($e)` }

            match _ ? e.isGlobal()              { js`___OUTER___.$e` }
            match _                             { e }
        }}
        to visitRead() { return switch (e) {
            match js`@_.@{p}__`                 { throw(`Properties cannot end in "__": ${p}__`) }
            match js`this.@p`                   { js`this.${p}_canRead___ ? this.$p :
                                                     ___.readProp(this, ${`$p`})`
                                                }
            match js`@_.@{p}_`                  { throw(`Public properties cannot end in "_": ${p}_`) }
            match js`@o.@p`                     { def [o2,o3] := reuse(o, scope)
                                                  js`$o2.${p}_canRead___ ? $o3.$p :
                                                     ___.readPub($o3, ${`$p`})`
                                                }
            match js`this[@s]`                  { def s2 := expand(s, scope)
                                                  js`___.readProp(this, $s2)` 
                                                }
            match js`@o[@s]`                    { def o2 := expand(o, scope)
                                                  def s2 := expand(s, scope)
                                                  js`___.readPub($o2, $s2)` 
                                                }
        }}
        to visitSet() { return switch (e) {
            match js`@_.@{p}__ = @_`            { throw(`Properties cannot end in "__": ${p}__`) }
            match js`this.@p = @r`              { def [r2,r3] := reuse(r, scope)
                                                  js`$r2, (this.${p}_canSet___ ? this.$p = $r3 :
                                                           ___.setProp(this, ${`$p`}, $r3))`
                                                }

            # Exempts fname from expansion, so its
            # ".prototype" can continue to be initialized if fname has
            # not yet been frozen. It also allows methods to appear on
            # the right hand side. 
            # By placing this ahead of the next production, we allow
            # ".prototype" members to end in a single "_", so they can be
            # internal. 
            match js`@fname.prototype.@p = @m` ?
                  (fname.isFuncName() &&
                   `$p` !~ `constructor`)       { def m2 := expandMember(fname, m, scope)
                                                  js`___.setMember($fname, ${`$p`}, $m2)`
                                                }
            match js`@_.@{p}_ = @_`             { throw(`Public properties cannot end in "_": ${p}_`) }

            # Exempt fname from expansion, so its
            # ".prototype" can be initialized all at once by a map
            # expression that may contain methods (if fname has not
            # yet been frozen).
            match js`@fname.prototype = @mm` ? 
                  fname.isFuncName()            { def mm2 := expandMemberMap(fname, mm, scope)
                                                  js`___.setMemberMap($fname, $mm2)`
                                                }

            # Exempt fname from expansion, so it can
            # continue to be initialized if it has not yet been frozen. 
            match js`@fname.@p = @r` ? 
                  (fname.isFuncName() &&
                   `$p` !~ `Super`)             { def r2 := expand(r, scope)
                                                  js`___.setPub($fname, ${`$p`}, $r2)`
                                                }
            match js`@o.@p = @r`                { def [o2,o3] := reuse(o, scope)
                                                  def [r2,r3] := reuse(r, scope)
                                                  js`$o2, $r2, ($o3.${p}_canSet___ ? $o3.$p = $r3 :
                                                                ___.setPub($o3, ${`$p`}, $r3)`
                                                }
            match js`this[@s] = @r`             { def s2 := expand(s, scope)
                                                  def r2 := expand(r, scope)
                                                  js`___.setProp(this, $s2, $r2)` 
                                                }
            match js`@o[@s] = @r`               { def o2 := expand(o, scope)
                                                  def s2 := expand(s, scope)
                                                  def r2 := expand(r, scope)
                                                  js`___.setPub($o2, $s2, $r2)` 
                                                }            
            match js`@v = @r` ? 
                  v.isVar() &&
                  !(v.isFuncName())             { expandDef(v, expand(r, scope)) }
            match js`var @v = @r` ? 
                  v.isVar() &&
                  !(v.isFuncName())             { expandDef(v, expand(r, scope)) }
            match js`var @v` ? 
                  v.isVar() &&
                  !(v.isFuncName())             { expandDef(v, js`undefined`) }
        }}
        to visitNew() { return switch (e) {
            # Exempt ctor from expansion, which would reject it, but
            # freeze ctor here in case this is its first
            # non-initialization use.
            match js`new @ctor(@as*)` ?
                  ctor.isCtorName()             { def a2s := expandAll(as, scope)
                                                  js`new (___.asCtor($ctor))($a2s*)`
                                                }
            match js`new @f(@as*)`              { def f2  := expand(f, scope)
                                                  def a2s := expandAll(as, scope)
                                                  js`new (___.asCtor($f2))($a2s*)` 
                                                }
        }}
        to visitCall() { return switch (e) {
            match js`@_.@{m}__(@_*)`            { throw(`Selectors cannot end in "__": ${m}__`) }
            match js`this.@m(@as*)`             { def [a2s,a3s] := reuseAll(as, scope)
                                                  js`$a2s*, (this.${m}_canCall___ ? this.$m($a3s*) :
                                                             ___.callProp(this, ${`$m`}, [$a3s*]))` 
                                                }
            match js`@_.@{m}_(@_*)`             { throw(`Public selectors cannot end in "_": ${m}_`) }

            # Exempt both fname and base from further
            # expansion. caja.def will freeze base in case this is its first
            # non-initialization use, in order to prevent further
            # initialization. Note that we do not statically prevent
            # other calls to caja.def that do not match these two
            # cases. We simply handle them as regular method calls.
            match js`caja.def(@fname,@base)` ?
                  fname.isFuncName() &&
                  base.isFuncName()             { js`caja.def($fname,$base)` }

            # As above, but also allow a map containing methods in the
            # third argument.
            match js`caja.def(@fname,@base,@mm,@ss?)` ?
                  (fname.isFuncName() &&
                   base.isFuncName() &&
                   mm =~ js`({@_*})`)           { def mm2   := expandMemberMap(fname, mm, scope)
                                                  def s2s   := expandAll(ss, scope)
                                                  js`caja.def($fname,$base,$mm2,$s2s?)`
                                                }
            match js`@o.@m(@as*)`               { def [o2,o3]   := reuse(o, scope)
                                                  def [a2s,a3s] := reuseAll(as, scope)
                                                  js`$o2, $a2s*, ($o3.${m}_canCall___ ? $o3.$m($a3s*) :
                                                                  ___.callPub($o3, ${`$m`}, [$a3s*]))` 
                                                }
            match js`this[@s](@as*)`            { def s2  := expand(s, scope)
                                                  def a2s := expandAll(as, scope)
                                                  js`___.callProp(this, $s2, [$a2s*])`
                                                }
            match js`@o[@s](@as*)`              { def o2  := expand(o, scope)
                                                  def s2  := expand(s, scope)
                                                  def a2s := expandAll(as, scope)
                                                  js`___.callPub($o2, $s2, [$a2s*])`
                                                }
            match js`@f(@as*)`                  { def f2  := expand(f, scope)
                                                  def a2s := expandAll(as, scope)
                                                  js`___.asSimpleFunc($f2)($a2s*)`
                                                }
        }}
        to visitFunction() { return switch (e) {
            # anonymous simple function
            match js`function(@ps*) {@bs*}` ?
                  !(anyFreeThis(bs))            { def scope2 := scope.nest(e)
                                                  def b2s    := expandAll(bs, scope2)
                                                  js`___.primFreeze(___.simpleFunction(function($ps*) {
                                                       ${scope2.tempDefs()}*;
                                                       $b2s*
                                                  }))`
                                                }
            # Named simple function used for value
            match js`function @f(@ps*) {@bs*}` ?
                  e.isForValue() &&
                  !(anyFreeThis(bs))            { def scope2 := scope.nest(e)
                                                  def b2s    := expandAll(bs, scope2)
                                                  expandDef(f, js`___.primFreeze(___.simpleFunction(function($ps*) {
                                                       ${scope2.tempDefs()}*;
                                                       $b2s*
                                                     }))`)
                                                }
            # Named simple function declaration
            match js`function @f(@ps*) {@bs*}` ?
                  !(anyFreeThis(bs))            { def scope2 := scope.nest(e)
                                                  def b2s    := expandAll(bs, scope2)
                                                  expandDef(f, js`___.simpleFunction(function($ps*) {
                                                       ${scope2.tempDefs()}*;
                                                       $b2s*
                                                     })`)
                                                }

            # Methods can only appear is expandMember contexts
            match js`function(@_*) {@bs*}` ?
                  anyFreeThis(bs)               { throw(`Method in non-method context: $e`) }

            # Constructors can't be evaluated for their value
            match js`function @f(@ps*) {
                       @bs*
                     }` ?
                  e.isForValue() &&
                  anyFreeThis(bs)               { throw(`Constructor can't escape: $e`) }

            # A constructor first calling its super constructor to initialize this
            match js`function @f(@ps*) {
                       $f.Super.call(this, @as*);
                       @bs*
                     }` ?
                  !(anyFreeThis(as))            { def scope2 := scope.nest(e)
                                                  def a2s    := expandAll(as, scope2)
                                                  def b2s    := expandAll(bs, scope2)
                                                  expandDef(f, js`___.ctor(function($ps*) {
                                                       ${scope2.tempDefs()}*;
                                                       $f2.Super.call___(this, $a2s*);
                                                       $b2s*
                                                     })`)
                                                }
            # A constructor
            match js`function @f(@ps*) {
                       @bs*
                     }` ?
                  anyFreeThis(bs)               { def scope2 := scope.nest(e)
                                                  def b2s    := expandAll(bs, scope2)
                                                  expandDef(f, js`___.ctor(function($ps*) {
                                                       ${scope2.tempDefs()}*;
                                                       $b2s*
                                                     })`)
                                                }
        }}
        to visitMap() { return switch (e) {
            match js`({})`                    { js`({})` }
            match js`({@{key}_: @_, @_*})`    { throw(`Key may not end in "_": ${key}_`) }
            match js`({@key: @val, @rests*})` ?
                  scope.isIdent(key)          { def val2             := expand(val, scope)
                                                def js`({@rest2s*})` := expand(js`({$rests*})`, scope)
                                                js`({$key: $mem2, $rest2s*})`
                                              }
            match js`({@keyExpr: @_, @_*})`   { throw(`Key expressions not yet supported: $keyExpr`) }
        }}
        to visitOther() { return switch (e) {
            # A function or constructor name can be used on the right
            # of an instanceof without constraint 
            match js`$o instanceof $f` ?
                  f.isFuncName()              { def o2 := expand(o, scope)
                                                js`$o2 instanceof $f`
                                              }
        }}
    }
}
