#!/usr/bin/env rune

# Copyright (C) 2007 Google Inc.
#      
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ..............................................................................


pragma.syntax("0.9")

def js__quasiParser := <import:com.google.caja.js__quasiParser>

def expand

/** 
 * Given a list of untranslated expressions, return a list 
 * of translated expressions.
 */
def expandAll(exprs, scope) {
    var result := []
    for e in exprs {
        result with= expand(e, scope)
    }
    return result
}

/** 
 * Given an untranslated expression whose translated value
 * must appear multiple places, return a pair of a translated
 * expression for the first appearance and a translated 
 * expression for the remaining appearances.
 */
def reuse(e, scope) {
    def e2 := expand(e, scope)
    if (scope.isSimple(e2)) {
        return [e2,e2]
    } else {
        def temp := scope.makeTemp()
        return [js`$temp = $e2`, temp]
    }
}

/**
 * Given a list of untranslated expressions whose translated
 * values must appear multiple places, return a pair of
 * a list of all the translated first appearances and all the
 * translated remaining appearances.
 */
def reuseAll(exprs, scope) {
    var e2s := []
    var e3s := []
    for e in exprs {
        def [e2,e3] := reuse(e, scope)
        e2s with= e2
        e3s with= e3
    }
    return [e2s,e3s]
}

/**
 * Given that member is an untranslated expression that may 
 * be a method in the context of constructor ctor, return 
 * the corresponding translated expression.
 */
def expandMember(ctor, member, scope) {
    if (!scope.isRawCtor(ctor))           { throw(`internal: not a raw ctor: $ctor`) }
    
    return switch (member) {
        match js`function(@ps*) {@b}` ? 
              !scope.isThisless(b)        { def scope2 := scope.nest()
                                            def p2s    := scope2.defineAll(ps)
                                            def b2     := expand(b, scope2)
                                            js`___.method($ctor,function($p2s*) {
                                                 ${scope2.tempDefs()};
                                                 $b2
                                               })`
                                          }
        match _                           { expand(member, scope) }            
}

/**
 * Given that optMemberMap is either the empty list, 
 * signifying absence, or a singleton list of JSON
 * object-map expression whose values may be methods in
 * the context of constructor ctor, return the 
 * corresponding optional translated object-map expression.
 */
def expandOptMembers(ctor, optMemberMap, scope) {
    if (!scope.isRawCtor(ctor))           { throw(`internal: not a raw ctor: $ctor`) }
    
    return switch (optMemberMap) {
        match []                          { [] }
        
        match [js`{(@ks: @ms)*}`]         { var m2s := []
                                            for i => m in ms {
                                                if (ks[i] =~ js`@{_}_`) {
                                                    throw(`Key may not end in "_": ${ks[i]}`)
                                                }
                                                m2s with= expandMember(ctor, m, scope)
                                            }
                                            [js`{($ks: $m2s)*}`]
                                          }
    }
}
                                                

/**
 * Given an untranslated expression and a scope, return a
 * corresponding translated expression.
 */
bind expand(e, scope) {
    return scope.visit(e, def visitor {
        to visitWith()                          { throw(`"with" disallowed: $e`) }
        to visitVar() { return switch (e) {
            match js`arguments`                 { scope.hasArguments()
                                                  js`___args___`
                                                }
            match js`@{_}__`                    { throw(`Variables cannot end in "__": $e`) }
            match js`@{_}_` ? scope.isGlobal(e) { throw(`Globals cannot end in "_": $e`) }
            match _ ? scope.isCtor(e)           { throw(`Constructors are not first class: $e`) }
            match _ ? scope.isGlobal(e)         { js`___OUTER___.$e` }
            match _                             { e }
        }}
        to visitRead() { return switch (e) {
            match js`@_.@{p}__`                 { throw(`Properties cannot end in "__": ${p}__`) 
                                                }
            match js`this.@p`                   { js`this.${p}_canRead___ ? this.$p :
                                                     ___.readProp(this, ${`$p`})`
                                                }
            match js`@_.@{p}_`                  { throw(`Public properties cannot end in "_": ${p}_`)
                                                }
            match js`@o.@p`                     { def [o2,o3] := reuse(o, scope)
                                                  js`$o2.${p}_canRead___ ? $o3.$p :
                                                     ___.readPub($o3, ${`$p`})`
                                                }
            match js`this[@s]`                  { def s2 := expand(s, scope)
                                                  js`___.readProp(this, $s2)` 
                                                }
            match js`@o[@s]`                    { def o2 := expand(o, scope)
                                                  def s2 := expand(s, scope)
                                                  js`___.readPub($o2, $s2)` 
                                                }
        }}
        to visitSet() { return switch (e) {
            match js`@_.@{p}__ = @_`            { throw(`Properties cannot end in "__": ${p}__`) 
                                                }
            match js`this.@p = @r`              { def [r2,r3] := reuse(r, scope)
                                                  js`$r2, (this.${p}_canSet___ ? this.$p = $r3 :
                                                           ___.setProp(this, ${`$p`}, $r3))`
                                                }
            match js`@_.@{p}_ = @_`             { throw(`Public properties cannot end in "_": ${p}_`)
                                                }
            match js`@c.@p = @r` ? 
                  scope.isRawCtor(c)            { def r2 := expand(r, scope)
                                                  js`___.setPub($c, ${`$p`}, $r2)`
                                                }
            match js`@c.prototype.@p = @m` ?
                  scope.isRawCtor(c)            { def m2 := expandMember(c, m, scope)
                                                  js`___.setMember($c.prototype, ${`$p`}, $m2)`
                                                }
            match js`@o.@p = @r`                { def [o2,o3] := reuse(o, scope)
                                                  def [r2,r3] := reuse(r, scope)
                                                  js`$o2, $r2, ($o3.${p}_canSet___ ? $o3.$p = $r3 :
                                                                ___.setPub($o3, ${`$p`}, $r3)`
                                                }
            match js`this[@s] = @r`             { def s2 := expand(s, scope)
                                                  def r2 := expand(r, scope)
                                                  js`___.setProp(this, $s2, $r2)` 
                                                }
            match js`@o[@s] = @r`               { def o2 := expand(o, scope)
                                                  def s2 := expand(s, scope)
                                                  def r2 := expand(r, scope)
                                                  js`___.setPub($o2, $s2, $r2)` 
                                                }            
            match js`@v = @r` ? scope.isVar(v)  { def v2 := scope.define(v)
                                                  def r2 := expand(r, scope)
                                                  js`$v2 = $r2`
                                                }
            match js`var @v = @r` ? 
                  scope.isVar(v)                { def v2 := scope.define(v)
                                                  def r2 := expand(r, scope)
                                                  js`$v2 = $r2`
                                                }
            match js`var @v` ? 
                  scope.isVar(v)                { def v2 := scope.define(v)
                                                  js`$v2 = undefined`
                                                }
        }}
        to visitNew() { return switch (e) {
            match js`new @v(@as*)` ?
                  scope.isCtor(v)               { def v2  := scope.useCtor(v)
                                                  def a2s := expandAll(as, scope)
                                                  js`new $v2($a2s*)` 
                                                }
            match js`new @f(@as*)`              { def f2  := expand(f, scope)
                                                  def a2s := expandAll(as, scope)
                                                  js`new $f2($a2s*)` 
                                                }
        }}
        to visitCall() { return switch (e) {
            match js`@_.@{m}__(@_*)`            { throw(`Selectors cannot end in "__": ${m}__`) 
                                                }
            match js`this.@m(@as*)`             { def [a2s,a3s] := reuseAll(as, scope)
                                                  js`$a2s*, (this.${m}_canCall___ ? this.$m($a3s*) :
                                                             ___.invokeProp(this, ${`$m`}, [$a3s*]))` 
                                                }
            match js`@_.@{m}_(@_*)`             { throw(`Public selectors cannot end in "_": ${m}_`) 
                                                }
            match js`caja.def(@c,@base,
                              @ms?,@ss?)` ?
                   scope.isRawCtor(c) &&
                   scope.isCtor(base)           { def base2 := scope.useCtor(base)
                                                  def m2s   := expandOptMembers(c, ms, scope)
                                                  def s2s   := expandAll(ss, scope)
                                                  js`caja.def($c,$base2,$m2s?,$s2s?)`
                                                }
            match js`@o.@m(@as*)`               { def [o2,o3]   := reuse(o, scope)
                                                  def [a2s,a3s] := reuseAll(as, scope)
                                                  js`$o2, $a2s*, ($o3.${m}_canCall___ ? $o3.$m($a3s*) :
                                                                  ___.invokePub($o3, ${`$m`}, [$a3s*]))` 
                                                }
            match js`this[@s](@as*)`            { def s2  := expand(s, scope)
                                                  def a2s := expandAll(as, scope)
                                                  js`___.invokeProp(this, $s2, [$a2s*])`
                                                }
            match js`@o[@s](@as*)`              { def o2  := expand(o, scope)
                                                  def s2  := expand(s, scope)
                                                  def a2s := expandAll(as, scope)
                                                  js`___.invokePub($o2, $s2, [$a2s*])`
                                                }
            match js`@f(@as*)`                  { def f2  := expand(f, scope)
                                                  def a2s := expandAll(as, scope)
                                                  js`$f2.call___(___.USELESS, $a2s*)`
                                                }
        }}
        to visitFunction() { return switch (e) {
            match js`function(@ps*) {@b}` ?
                  scope.isThisless(b)           { def scope2 := scope.nest()
                                                  def p2s    := scope2.defineAll(ps)
                                                  def b2     := expand(b, scope2)
                                                  js`___.freeze(function($p2s*) {
                                                       ${scope2.tempDefs()};
                                                       $b2; 
                                                       return undefined; 
                                                     })`
                                                }
            match js`function @f(@ps*) {@b}` ?
                  scope.isThisless(b)           { def f2     := scope.define(f)
                                                  def scope2 := scope.nest()
                                                  def p2s    := scope2.defineAll(ps)
                                                  def b2     := expand(b, scope2)
                                                  js`$f2 = ___.freeze(function($p2s*) {
                                                       ${scope2.tempDefs()};
                                                       $b2; 
                                                       return undefined; 
                                                     })`
                                                }
            match js`function(@_*) {@_}`        { throw(`Method in non-method context: $e`) 
                                                }
            match js`function @f(@ps*) {
                       $f.Super.call(this, @as*);
                       @b
                     }`                         { def f2     := scope.defineCtor(f)
                                                  def scope2 := scope.nest()
                                                  def p2s    := scope2.defineAll(ps)
                                                  def a2s    := expandAll(as, scope2)
                                                  def b2     := expand(b, scope2)
                                                  js`$f2 = ___.ctor(function($p2s*) {
                                                       ${scope2.tempDefs()};
                                                       $f2.Super.call___(this, $a2s*);
                                                       $b2
                                                     })`
                                                }
            match js`function @f(@ps*) {
                       @b
                     }`                         { def f2     := scope.defineCtor(f)
                                                  def scope2 := scope.nest()
                                                  def p2s    := scope2.defineAll(ps)
                                                  def b2     := expand(b, scope2)
                                                  js`$f2 = ___.ctor(function($p2s*) {
                                                       ${scope2.tempDefs()};
                                                       $b2
                                                     })`
                                                }
        }}
        to visitMap() { return switch (e) {
            match js`{(@ks: @xs)*}`             { var x2s := []
                                                  for i => x in xs {
                                                      if (ks[i] =~ js`@{_}_`) {
                                                          throw(`Key may not end in "_": ${ks[i]}`)
                                                      }
                                                      x2s with= expand(x, scope)
                                                  }
                                                  js`{($ks: $x2s)*}`
                                                }
        }}
    }
}
                    
